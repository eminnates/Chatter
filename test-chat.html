<!DOCTYPE html>
<html>
<head>
    <title>Chatter SignalR Test</title>
    <!-- Microsoft SignalR Client Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, textarea { width: 100%; padding: 8px; margin-bottom: 10px; box-sizing: border-box; }
        button { padding: 10px 20px; cursor: pointer; background-color: #007bff; color: white; border: none; }
        button:disabled { background-color: #ccc; }
        
        .main-area { display: flex; gap: 20px; margin-top: 20px; }
        .sidebar { width: 30%; border-right: 1px solid #ddd; padding-right: 15px; }
        .chat-panel { width: 70%; }
        
        .list-container { border: 1px solid #ddd; height: 200px; overflow-y: auto; margin-bottom: 15px; background: #f9f9f9; }
        .list-item { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; }
        .list-item:hover { background-color: #e9ecef; }
        .list-item.active { background-color: #007bff; color: white; }
        
        #messagesList { border: 1px solid #ddd; padding: 10px; height: 400px; overflow-y: auto; background: #fff; margin-bottom: 10px; }
        .message { margin-bottom: 8px; padding: 8px; border-radius: 5px; max-width: 80%; }
        .system { color: #888; font-style: italic; text-align: center; width: 100%; }
        .received { background-color: #f1f0f0; float: left; clear: both; }
        .sent { background-color: #dcf8c6; float: right; clear: both; text-align: right; }
        .clearfix::after { content: ""; clear: both; display: table; }
        
        .badge { background: red; color: white; padding: 2px 6px; border-radius: 10px; font-size: 12px; margin-left: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h2>Chatter SignalR Test Client</h2>
        
        <div class="input-group">
            <label>JWT Token (Login first to get this):</label>
            <input type="text" id="tokenInput" placeholder="Paste your Bearer token here...">
        </div>

        <div class="input-group">
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            <span id="status">Disconnected</span>
        </div>

        <div id="chatArea" style="display:none;" class="main-area">
            <!-- Sidebar: Users & Conversations -->
            <div class="sidebar">
                <h3>My Conversations</h3>
                <div id="conversationList" class="list-container">
                    <div style="padding:10px; color:#666;">Loading...</div>
                </div>

                <h3>Available Users</h3>
                <div id="userList" class="list-container">
                    <div style="padding:10px; color:#666;">Loading...</div>
                </div>
            </div>

            <!-- Chat Panel -->
            <div class="chat-panel">
                <h3 id="chatHeader">Select a conversation or user</h3>
                <div id="messagesList" class="clearfix"></div>
                
                <div class="input-group">
                    <input type="hidden" id="receiverIdInput">
                    <input type="text" id="messageInput" placeholder="Type a message..." disabled>
                    <button id="sendBtn" disabled>Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let connection = null;
        let currentConversationId = null;
        let currentReceiverId = null;
        let currentUserToken = null;

        // Use HTTP to avoid SSL certificate trust issues during development
        const BASE_URL = "http://localhost:5157"; 
        const HUB_URL = `${BASE_URL}/hubs/chat`;
        const API_URL = `${BASE_URL}/api`;

        const tokenInput = document.getElementById("tokenInput");
        const connectBtn = document.getElementById("connectBtn");
        const disconnectBtn = document.getElementById("disconnectBtn");
        const statusSpan = document.getElementById("status");
        const chatArea = document.getElementById("chatArea");
        const messagesList = document.getElementById("messagesList");
        const sendBtn = document.getElementById("sendBtn");
        const messageInput = document.getElementById("messageInput");
        const userListDiv = document.getElementById("userList");
        const conversationListDiv = document.getElementById("conversationList");
        const chatHeader = document.getElementById("chatHeader");

        function log(message, type = 'system', senderName = '') {
            const div = document.createElement("div");
            div.className = `message ${type}`;
            
            if (type === 'received') {
                div.innerHTML = `<strong>${senderName}</strong><br>${message}`;
            } else if (type === 'sent') {
                div.innerHTML = `${message}`;
            } else {
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            }
            
            messagesList.appendChild(div);
            messagesList.scrollTop = messagesList.scrollHeight;
        }

        connectBtn.addEventListener("click", async () => {
            if (typeof signalR === 'undefined') {
                alert("SignalR library not loaded!");
                return;
            }

            const token = tokenInput.value.trim();
            if (!token) {
                alert("Please enter a JWT Token");
                return;
            }
            currentUserToken = token;

            try {
                connection = new signalR.HubConnectionBuilder()
                    .withUrl(HUB_URL, {
                        accessTokenFactory: () => token
                    })
                    .withAutomaticReconnect()
                    .configureLogging(signalR.LogLevel.Information)
                    .build();

                // Listen for messages
                connection.on("ReceiveMessage", (messageDto) => {
                    console.log("Received:", messageDto);
                    
                    // If message belongs to current conversation, show it
                    if (currentConversationId && messageDto.conversationId === currentConversationId) {
                        const isMine = false; // We can't easily know without decoding token, but usually 'sent' handles mine
                        // Actually, if we receive it via SignalR and we are the sender, we also get it.
                        // But let's assume 'received' for now unless we check senderId
                        
                        // Simple check: if I sent it, I already logged it? 
                        // No, the server sends it back to sender too.
                        // Let's just log it.
                        log(messageDto.content, 'received', messageDto.senderName);
                    } else {
                        // Notification for other conversation
                        // Refresh conversation list to show unread count or new last message
                        fetchConversations();
                    }
                });

                await connection.start();
                
                statusSpan.textContent = "Connected";
                statusSpan.style.color = "green";
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                chatArea.style.display = "flex";
                
                // Initial Data Load
                fetchUsers();
                fetchConversations();

            } catch (err) {
                console.error(err);
                alert("Connection failed: " + err.message);
            }
        });

        disconnectBtn.addEventListener("click", async () => {
            if (connection) {
                await connection.stop();
                statusSpan.textContent = "Disconnected";
                statusSpan.style.color = "black";
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                chatArea.style.display = "none";
            }
        });

        async function fetchUsers() {
            try {
                const response = await fetch(`${API_URL}/user`, {
                    headers: { "Authorization": `Bearer ${currentUserToken}` }
                });
                const result = await response.json();
                
                if (result.success) {
                    userListDiv.innerHTML = "";
                    result.data.forEach(user => {
                        const div = document.createElement("div");
                        div.className = "list-item";
                        div.textContent = `${user.userName} (${user.fullName})`;
                        div.onclick = () => startNewChat(user);
                        userListDiv.appendChild(div);
                    });
                }
            } catch (err) {
                userListDiv.textContent = "Error loading users.";
            }
        }

        async function fetchConversations() {
            try {
                const response = await fetch(`${API_URL}/chat/conversations`, {
                    headers: { "Authorization": `Bearer ${currentUserToken}` }
                });
                const result = await response.json();
                
                if (result.success) {
                    conversationListDiv.innerHTML = "";
                    if (result.data.length === 0) {
                        conversationListDiv.innerHTML = "<div style='padding:10px'>No conversations yet.</div>";
                        return;
                    }

                    result.data.forEach(conv => {
                        const div = document.createElement("div");
                        div.className = `list-item ${currentConversationId === conv.id ? 'active' : ''}`;
                        
                        let content = `<strong>${conv.name}</strong>`;
                        if (conv.unreadCount > 0) {
                            content += `<span class="badge">${conv.unreadCount}</span>`;
                        }
                        content += `<br><small>${conv.lastMessage || 'No messages'}</small>`;
                        
                        div.innerHTML = content;
                        div.onclick = () => loadConversation(conv);
                        conversationListDiv.appendChild(div);
                    });
                }
            } catch (err) {
                conversationListDiv.textContent = "Error loading conversations.";
            }
        }

        function startNewChat(user) {
            currentConversationId = null;
            currentReceiverId = user.id;
            
            // UI Updates
            chatHeader.textContent = `New Chat with ${user.userName}`;
            messagesList.innerHTML = "<div class='system'>Start a new conversation...</div>";
            enableInput();
            
            // Highlight nothing in conv list
            document.querySelectorAll('#conversationList .list-item').forEach(el => el.classList.remove('active'));
        }

        async function loadConversation(conversation) {
            currentConversationId = conversation.id;
            currentReceiverId = null; // We use conversationId now
            
            // UI Updates
            chatHeader.textContent = conversation.name;
            messagesList.innerHTML = "<div class='system'>Loading messages...</div>";
            enableInput();
            
            // Highlight
            document.querySelectorAll('#conversationList .list-item').forEach(el => el.classList.remove('active'));
            // Find the element we just clicked (re-rendering list might lose reference, but fetchConversations is called often)
            // For now, just fetch messages
            
            try {
                const response = await fetch(`${API_URL}/chat/messages/${conversation.id}`, {
                    headers: { "Authorization": `Bearer ${currentUserToken}` }
                });
                const result = await response.json();
                
                if (result.success) {
                    messagesList.innerHTML = "";
                    // Messages come newest first usually, or we need to reverse?
                    // API returns paginated, usually newest first or oldest first depending on implementation.
                    // Let's assume we need to reverse to show oldest at top
                    const msgs = result.data.reverse(); 
                    
                    msgs.forEach(msg => {
                        // Determine if sent or received (simple check: if senderName is 'You' or similar? No, API returns senderName)
                        // We don't have our own ID easily. Let's just use 'received' style for all for now, 
                        // or try to guess.
                        log(msg.content, 'received', msg.senderName);
                    });
                    
                    // Mark as read
                    markAsRead(conversation.id);
                }
            } catch (err) {
                messagesList.innerHTML = "<div class='system'>Error loading messages.</div>";
            }
        }
        
        async function markAsRead(conversationId) {
            await fetch(`${API_URL}/chat/read/${conversationId}`, {
                method: 'POST',
                headers: { "Authorization": `Bearer ${currentUserToken}` }
            });
            // Refresh list to clear badge
            fetchConversations();
        }

        function enableInput() {
            messageInput.disabled = false;
            sendBtn.disabled = false;
            messageInput.focus();
        }

        sendBtn.addEventListener("click", async () => {
            const content = messageInput.value.trim();
            if (!content) return;

            const request = {
                content: content,
                conversationId: currentConversationId,
                receiverId: currentReceiverId
            };

            try {
                await connection.invoke("SendMessage", request);
                // Manually append my message (optional, as server sends it back too)
                // But for better UX, append immediately
                log(content, 'sent');
                messageInput.value = "";
                
                // If this was a new chat, refresh conversations to show it
                if (!currentConversationId) {
                    setTimeout(fetchConversations, 1000);
                }
            } catch (err) {
                console.error(err);
                alert("Error sending message");
            }
        });
        
        // Allow Enter key to send
        messageInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") sendBtn.click();
        });
    </script>
</body>
</html>
